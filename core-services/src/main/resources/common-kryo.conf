akka {

  extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension$"]


  actor {

    serializers {
      kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
    }
    serialization-bindings {
      //      "rs.core.KryoSer" = kryo
      "rs.core.services.internal.acks.AcknowledgeableWithSpecificId" = kryo
      "rs.core.services.internal.acks.Acknowledgement" = kryo
      "rs.core.ServiceKey" = kryo
      "rs.core.TopicKey" = kryo
      "java.lang.String" = kryo

      "rs.core.services.BaseServiceActor$StreamMapping" = kryo
      "rs.core.services.BaseServiceActor$GetMappingFor" = kryo

      "rs.core.services.internal.InternalMessages$StreamUpdate" = kryo
      "rs.core.services.internal.InternalMessages$SignalPayload" = kryo
      "rs.core.services.internal.InternalMessages$DownstreamDemandRequest" = kryo

      "rs.core.services.Messages$SignalAckOk" = kryo
      "rs.core.services.Messages$SignalAckFailed" = kryo
    }
    kryo {
      # Possibles values for type are: graph or nograph
      # graph supports serialization of object graphs with shared nodes
      # and cyclic references, but this comes at the expense of a small overhead
      # nograph does not support object grpahs with shared nodes, but is usually faster
      type = "nograph"


      # Possible values for idstrategy are:
      # default, explicit, incremental
      #
      # default - slowest and produces bigger serialized representation. Contains fully-
      # qualified class names (FQCNs) for each class. Note that selecting this strategy
      # does not work in version 0.3.2, but is available on master and from 0.3.3 onward.
      #
      # explicit - fast and produces compact serialized representation. Requires that all
      # classes that will be serialized are pre-registered using the "mappings" and "classes"
      # sections. To guarantee that both sender and receiver use the same numeric ids for the same
      # classes it is advised to provide exactly the same entries in the "mappings" section
      #
      # incremental - fast and produces compact serialized representation. Support optional
      # pre-registering of classes using the "mappings" and "classes" sections. If class is
      # not pre-registered, it will be registered dynamically by picking a next available id
      # To guarantee that both sender and receiver use the same numeric ids for the same
      # classes it is advised to pre-register them using at least the "classes" section

      idstrategy = "incremental"

      # Define a default size for serializer pool
      # Try to define the size to be at least as big as the max possible number
      # of threads that may be used for serialization, i.e. max number
      # of threads allowed for the scheduler
      serializer-pool-size = 16

      # Define a default size for byte buffers used during serialization
      buffer-size = 4096

      # The serialization byte buffers are doubled as needed until they exceed max-buffer-size and an exception is thrown. Can be -1 for no maximum.
      max-buffer-size = -1

      # If set, akka uses manifests to put a class name
      # of the top-level object into each message
      use-manifests = false

      # Enable transparent compression of serialized messages
      # accepted values are: off | lz4 | deflate
      compression = lz4

      # Log implicitly registered classes. Useful, if you want to know all classes
      # which are serialized. You can then use this information in the mappings and/or
      # classes sections
      implicit-registration-logging = true

      # If enabled, Kryo logs a lot of information about serialization process.
      # Useful for debugging and lowl-level tweaking
      kryo-trace = false

      # If proviced, Kryo uses the class specified by a fully qualified class name
      # to perform a custom initialization of Kryo instances in addition to what
      # is done automatically based on the config file.
      #kryo-custom-serializer-init = "CustomKryoSerializerInitFQCN"

      classes = [
        "rs.core.ServiceKey",
        "rs.core.TopicKey",
        "rs.core.Subject",
        "rs.core.services.internal.acks.AcknowledgeableWithSpecificId",
        "rs.core.services.SequentialMessageId",

        "rs.core.services.BaseServiceActor$ServiceEndpoint",
        "rs.core.services.BaseServiceActor$OpenStreamFor",
        "rs.core.services.BaseServiceActor$CloseStreamFor",
        "rs.core.services.BaseServiceActor$StreamMapping",
        "rs.core.services.BaseServiceActor$GetMappingFor",
        "rs.core.services.BaseServiceActor$StreamResyncRequest",

        "rs.core.services.internal.acks.Acknowledgement",
        "rs.core.services.SimpleStreamId",
        "rs.core.services.CompoundStreamId",

        "rs.core.services.internal.InternalMessages$DownstreamDemandRequest",
        "rs.core.services.internal.InternalMessages$StreamUpdate",
        "rs.core.services.internal.InternalMessages$SignalPayload",


        "rs.core.stream.DictionaryMapStreamState",
        "rs.core.stream.DictionaryMapStreamState$Dictionary",
        "[Ljava.lang.String;",
        "[Ljava.lang.Object;",
        "rs.core.stream.DictionaryMapStreamTransitionPartial",
        "rs.core.stream.DictionaryMapStreamState$NoChange$",

        "rs.core.stream.StringStreamState",

        "rs.core.services.Messages$SignalAckOk",
        "rs.core.services.Messages$SignalAckFailed",

        "rs.core.stream.SetStreamState",
        "rs.core.stream.SetStreamState$SetSpecs",
        "rs.core.stream.SetStreamTransitionPartial",
        "[Lrs.core.stream.SetStreamState$SetOp;",
        "rs.core.stream.SetStreamState$Add",
        "rs.core.stream.SetStreamState$Remove",


        "akka.actor.Address",


        "scala.None$",
        "scala.Some",

        "akka.actor.LocalActorRef",


        "akka.actor.RepointableActorRef"

      ]
    }
  }
}